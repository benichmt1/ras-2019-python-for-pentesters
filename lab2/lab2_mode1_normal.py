#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  lab2.py
#  
################################################################################
# Lab 2
# =====
# Build a script to SSH into a host, execute a command to retrieve the
# environment variables then search for a series of sensitive information in
# files. The paramiko library is the only third party library in use here. The
# script will throw an error if the file it tries to access can not be read,
# handle it and move on.
#
# Core Concepts
# -------------
# * Issuing commands and reading / writing files over SSH
# * Parsing files with regular expressions (regexs)
#
# Bonus Challenges
# ----------------
# 1) Handle authentication errors to prevent stack traces with incorrect passwords.
# 2) Add support for key-based authentication.
# 3) Add support for recursively searching through directories.
#

import argparse
import collections
import functools
import getpass
import re
import sys

import paramiko

# define a query named tuple to represent things to search for
Query = collections.namedtuple('Query', ('path', 'regex', 'description'))
queries = (
    Query(
        '/etc/king-phisher/server_config.yml',
        r'^\s+database:\s+(?P<secret>post\S+)$',
        'king-phisher database connection string'
    ),
    Query(
        '/etc/shadow',
        r'^[\w-]+:(?P<secret>\$[^:\s]+):',
        'crypt(3) password'
    ),
    Query(
        '$HOME/.pypirc',
        r'^password[:=]\s+(?P<secret>\S+)$',
        '.pypirc file password'
    )
)

def get_env_vars(ssh_client, with_pty=True):
    # todo: use the ssh_client to execute the 'env' command on the remote host,
    #   parse the results, and return a dictionary of environment variables
    return variables

def _var_repl(env_vars, match):
    var = match.group('variable')
    value = env_vars.get(var)
    if value is None:
        return var
    return value

# this function is documented using reStructuredText in the format used by
# Sphinx's autodoc extension
def expand_vars(string, env_vars=None):
    """
    Expand environment variables that are provided just like os.path.expandvars
    would, but using the specified *env_vars*.

    :param str string: The string to expand environment variables for.
    :param dict env_vars: The environment variables.
    :rtype: str
    """
    if env_vars is None:
        env_vars = os.environ
    # create a replacement callback function that uses env_vars as it's first
    # argument, additional arguments will be added after it
    repl_callback = functools.partial(_var_repl, env_vars)
    return re.sub(r'\$(?P<variable>[a-zA-Z]\w*)((?=[\W])|$)', repl_callback, string)

def main():
    # setup the arguments to consume from the command line
    parser = argparse.ArgumentParser(description='ssh file scanner')
    parser.add_argument('-p', '--port', default=22, type=int, help='the port to connect to')
    parser.add_argument('-V', '--verbose', action='store_true', default=False, help='print verbose output')
    parser.add_argument('target', help='the target to connect to')
    args = parser.parse_args()

    # get the username from the target if it's present otherwise use the current
    # user just like ssh does
    if '@' in args.target:
        username, _, target = args.target.partition('@')
    else:
        target = args.target
        username = getpass.getuser()

    password = # todo: get the password without it being displayed on the CLI (including as an argument)

    # define the transport, connect, authenticate and get an sftp client instance
    ssh_client = paramiko.SSHClient()
    ssh_client. # todo: handle missing host keys
    ssh_client. # todo: connect the ssh client
    print('successfully authenticated to: ' + target)

    env_vars = get_env_vars(ssh_client)
    print("[*] loaded {:,} environment variables".format(len(env_vars)))
    
    sftp = ssh_client. # todo: get the sftp channel from the ssh client
    # iterate through each of the quries, open the file if possible and search it
    for query in queries:
        # todo: open the file using sftp, handle exceptions and read it's contents

        first = True
        # todo: define a loop to iterate through regex matches in the data
            # todo: process regex matches of the query in the data, be sure to set line_number
            print("    [{: >4}] {}".format(line_number, match.group('secret')))
        file_h.close()
    ssh_client.close()

if __name__ == '__main__':
    main()
